**You:**

现在你是一位资深golang工程师，熟悉数据结构。请完成下面的题目，有一个n级的楼梯，你可以一次走1步或者2步或者3步，但是两次走的步数不能相同，如第一次走了1步，第二次就只能走2步或者3步，求走到n级台阶的方法数字

* * *

**ChatGPT:**

要解决这个问题，我们需要使用动态规划来计算到达每个台阶的方法数量。

我们定义 dp[i][j]dp[i][j]dp[i][j] 为到达第 i 级台阶，且最后一步为 j 的方法数量。其中 j 可以为 1、2 或 3。

状态转移方程为：

dp[i][1]=dp[i−1][2]+dp[i−1][3]

dp[i][2]=dp[i−2][1]+dp[i−2][3]

dp[i][3]=dp[i−3][1]+dp[i−3][2]

边界条件是：

dp[1][1]=1

dp[1][2]=0

dp[1][3]=0

dp[2][1]=0

dp[2][2]=1

dp[2][3]=0

dp[3][1]=0

dp[3][2]=1

dp[3][3]=1

要求到达第 n 级的方法数量，我们只需计算 dp[n][1]+dp[n][2]+dp[n][3]。

以下是使用 Go 语言实现的解决方案：

```go
package main

import "fmt"

func countWays(n int) int {
	if n <= 0 {
		return 0
	}

	dp := make([][4]int, n+1)

	dp[1][1] = 1
	dp[1][2] = 0
	dp[1][3] = 0

	if n > 1 {
		dp[2][1] = 0
		dp[2][2] = 1
		dp[2][3] = 0
	}

	if n > 2 {
		dp[3][1] = 0
		dp[3][2] = 1
		dp[3][3] = 1
	}

	for i := 4; i <= n; i++ {
		dp[i][1] = dp[i-1][2] + dp[i-1][3]
		dp[i][2] = dp[i-2][1] + dp[i-2][3]
		dp[i][3] = dp[i-3][1] + dp[i-3][2]
	}

	return dp[n][1] + dp[n][2] + dp[n][3]
}

func main() {
	n := 10
	fmt.Printf("Number of ways to reach %d-th stair: %d\n", n, countWays(n))
}
```

这段代码将输出到达第10级的方法数量。可以根据需要更改 `n` 的值来计算不同台阶数量的方法数。